//
// Generated file, do not edit! Created by nedtool 5.0 from inet/routing/epf/EPFControlPackets.msg.
//

#ifndef __INET_EPFCONTROLPACKETS_M_H
#define __INET_EPFCONTROLPACKETS_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0500
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/networklayer/common/L3Address.h"
#include "inet/routing/aodv/AODVControlPackets_m.h"
// }}


namespace inet {

/**
 * Enum generated from <tt>inet/routing/epf/EPFControlPackets.msg:42</tt> by nedtool.
 * <pre>
 * enum EPFControlPacketType
 * {
 * 
 *     //	RREQ = 1;
 *     //	RREP = 2;
 *     //	RERR = 3;
 *     //	RREPACK = 4;
 *     //	ContactInfo=5;
 *     Enquire = 6;
 *     Response = 7;
 *     Data = 8;
 *     ContactInfoMsg = 9;
 * }
 * </pre>
 */
enum EPFControlPacketType {
    Enquire = 6,
    Response = 7,
    Data = 8,
    ContactInfoMsg = 9
};

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:58</tt> by nedtool.
 * <pre>
 * //
 * // Base packet for EPF Control Packets
 * //
 * packet EPFControlPacket extends AODVControlPacket
 * {
 * }
 * </pre>
 */
class EPFControlPacket : public ::inet::AODVControlPacket
{
  protected:

  private:
    void copy(const EPFControlPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EPFControlPacket&);

  public:
    EPFControlPacket(const char *name=nullptr, int kind=0);
    EPFControlPacket(const EPFControlPacket& other);
    virtual ~EPFControlPacket();
    EPFControlPacket& operator=(const EPFControlPacket& other);
    virtual EPFControlPacket *dup() const {return new EPFControlPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EPFControlPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EPFControlPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:65</tt> by nedtool.
 * <pre>
 * //
 * // Represents an EPF Route Request
 * //
 * class EPFRREQ extends EPFControlPacket
 * {
 *     unsigned int packetType = RREQ;
 *     bool joinFlag;
 *     bool repairFlag;
 *     bool gratuitousRREPFlag;
 *     bool destOnlyFlag;
 *     bool unknownSeqNumFlag;
 *     unsigned int hopCount;
 *     unsigned int rreqId;
 *     L3Address destAddr;
 *     unsigned int destSeqNum;
 *     L3Address originatorAddr;
 *     unsigned int originatorSeqNum;
 * }
 * </pre>
 */
class EPFRREQ : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;
    bool joinFlag;
    bool repairFlag;
    bool gratuitousRREPFlag;
    bool destOnlyFlag;
    bool unknownSeqNumFlag;
    unsigned int hopCount;
    unsigned int rreqId;
    L3Address destAddr;
    unsigned int destSeqNum;
    L3Address originatorAddr;
    unsigned int originatorSeqNum;

  private:
    void copy(const EPFRREQ& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EPFRREQ&);

  public:
    EPFRREQ(const char *name=nullptr);
    EPFRREQ(const EPFRREQ& other);
    virtual ~EPFRREQ();
    EPFRREQ& operator=(const EPFRREQ& other);
    virtual EPFRREQ *dup() const {return new EPFRREQ(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
    virtual bool getJoinFlag() const;
    virtual void setJoinFlag(bool joinFlag);
    virtual bool getRepairFlag() const;
    virtual void setRepairFlag(bool repairFlag);
    virtual bool getGratuitousRREPFlag() const;
    virtual void setGratuitousRREPFlag(bool gratuitousRREPFlag);
    virtual bool getDestOnlyFlag() const;
    virtual void setDestOnlyFlag(bool destOnlyFlag);
    virtual bool getUnknownSeqNumFlag() const;
    virtual void setUnknownSeqNumFlag(bool unknownSeqNumFlag);
    virtual unsigned int getHopCount() const;
    virtual void setHopCount(unsigned int hopCount);
    virtual unsigned int getRreqId() const;
    virtual void setRreqId(unsigned int rreqId);
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<EPFRREQ*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual unsigned int getDestSeqNum() const;
    virtual void setDestSeqNum(unsigned int destSeqNum);
    virtual L3Address& getOriginatorAddr();
    virtual const L3Address& getOriginatorAddr() const {return const_cast<EPFRREQ*>(this)->getOriginatorAddr();}
    virtual void setOriginatorAddr(const L3Address& originatorAddr);
    virtual unsigned int getOriginatorSeqNum() const;
    virtual void setOriginatorSeqNum(unsigned int originatorSeqNum);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EPFRREQ& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EPFRREQ& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:84</tt> by nedtool.
 * <pre>
 * //
 * // Represents an EPF Route Reply
 * //
 * class EPFRREP extends EPFControlPacket
 * {
 *     unsigned int packetType = RREP;
 *     bool repairFlag;
 *     bool ackRequiredFlag;
 *     unsigned int prefixSize;
 *     unsigned int hopCount;
 *     L3Address destAddr;
 *     unsigned int destSeqNum;
 *     L3Address originatorAddr;
 *     unsigned int originatorSeqNum;
 *     simtime_t lifeTime;
 * }
 * </pre>
 */
class EPFRREP : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;
    bool repairFlag;
    bool ackRequiredFlag;
    unsigned int prefixSize;
    unsigned int hopCount;
    L3Address destAddr;
    unsigned int destSeqNum;
    L3Address originatorAddr;
    unsigned int originatorSeqNum;
    ::omnetpp::simtime_t lifeTime;

  private:
    void copy(const EPFRREP& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EPFRREP&);

  public:
    EPFRREP(const char *name=nullptr);
    EPFRREP(const EPFRREP& other);
    virtual ~EPFRREP();
    EPFRREP& operator=(const EPFRREP& other);
    virtual EPFRREP *dup() const {return new EPFRREP(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
    virtual bool getRepairFlag() const;
    virtual void setRepairFlag(bool repairFlag);
    virtual bool getAckRequiredFlag() const;
    virtual void setAckRequiredFlag(bool ackRequiredFlag);
    virtual unsigned int getPrefixSize() const;
    virtual void setPrefixSize(unsigned int prefixSize);
    virtual unsigned int getHopCount() const;
    virtual void setHopCount(unsigned int hopCount);
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<EPFRREP*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual unsigned int getDestSeqNum() const;
    virtual void setDestSeqNum(unsigned int destSeqNum);
    virtual L3Address& getOriginatorAddr();
    virtual const L3Address& getOriginatorAddr() const {return const_cast<EPFRREP*>(this)->getOriginatorAddr();}
    virtual void setOriginatorAddr(const L3Address& originatorAddr);
    virtual unsigned int getOriginatorSeqNum() const;
    virtual void setOriginatorSeqNum(unsigned int originatorSeqNum);
    virtual ::omnetpp::simtime_t getLifeTime() const;
    virtual void setLifeTime(::omnetpp::simtime_t lifeTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EPFRREP& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EPFRREP& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:101</tt> by nedtool.
 * <pre>
 * //
 * // Represents an EPF Route Error
 * //
 * class EPFRERR extends EPFControlPacket
 * {
 *     unsigned int packetType = RERR;
 *     UnreachableNode unreachableNodes[];
 *     bool noDeleteFlag;
 *     unsigned int destCount;
 * }
 * </pre>
 */
class EPFRERR : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;
    UnreachableNode *unreachableNodes; // array ptr
    unsigned int unreachableNodes_arraysize;
    bool noDeleteFlag;
    unsigned int destCount;

  private:
    void copy(const EPFRERR& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EPFRERR&);

  public:
    EPFRERR(const char *name=nullptr);
    EPFRERR(const EPFRERR& other);
    virtual ~EPFRERR();
    EPFRERR& operator=(const EPFRERR& other);
    virtual EPFRERR *dup() const {return new EPFRERR(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
    virtual void setUnreachableNodesArraySize(unsigned int size);
    virtual unsigned int getUnreachableNodesArraySize() const;
    virtual UnreachableNode& getUnreachableNodes(unsigned int k);
    virtual const UnreachableNode& getUnreachableNodes(unsigned int k) const {return const_cast<EPFRERR*>(this)->getUnreachableNodes(k);}
    virtual void setUnreachableNodes(unsigned int k, const UnreachableNode& unreachableNodes);
    virtual bool getNoDeleteFlag() const;
    virtual void setNoDeleteFlag(bool noDeleteFlag);
    virtual unsigned int getDestCount() const;
    virtual void setDestCount(unsigned int destCount);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EPFRERR& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EPFRERR& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:112</tt> by nedtool.
 * <pre>
 * //
 * // Represents an EPF Route Reply ACK
 * //
 * class EPFRREPACK extends EPFControlPacket
 * {
 *     unsigned int packetType = RREPACK;
 * }
 * </pre>
 */
class EPFRREPACK : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;

  private:
    void copy(const EPFRREPACK& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EPFRREPACK&);

  public:
    EPFRREPACK(const char *name=nullptr);
    EPFRREPACK(const EPFRREPACK& other);
    virtual ~EPFRREPACK();
    EPFRREPACK& operator=(const EPFRREPACK& other);
    virtual EPFRREPACK *dup() const {return new EPFRREPACK(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EPFRREPACK& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EPFRREPACK& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:116</tt> by nedtool.
 * <pre>
 * class CONTACTINFOMSG extends EPFControlPacket
 * {
 *     unsigned int packetType = ContactInfoMsg;
 *     unsigned int hostIndex;
 *     L3Address sourceAddr;
 * }
 * </pre>
 */
class CONTACTINFOMSG : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;
    unsigned int hostIndex;
    L3Address sourceAddr;

  private:
    void copy(const CONTACTINFOMSG& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CONTACTINFOMSG&);

  public:
    CONTACTINFOMSG(const char *name=nullptr);
    CONTACTINFOMSG(const CONTACTINFOMSG& other);
    virtual ~CONTACTINFOMSG();
    CONTACTINFOMSG& operator=(const CONTACTINFOMSG& other);
    virtual CONTACTINFOMSG *dup() const {return new CONTACTINFOMSG(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
    virtual unsigned int getHostIndex() const;
    virtual void setHostIndex(unsigned int hostIndex);
    virtual L3Address& getSourceAddr();
    virtual const L3Address& getSourceAddr() const {return const_cast<CONTACTINFOMSG*>(this)->getSourceAddr();}
    virtual void setSourceAddr(const L3Address& sourceAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CONTACTINFOMSG& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CONTACTINFOMSG& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:122</tt> by nedtool.
 * <pre>
 * class EnquireMessage extends EPFControlPacket
 * {
 *     unsigned int packetType = Enquire;
 *     unsigned int hostIndex;
 *     unsigned int destIndex;
 *     unsigned int seqNum;
 *     unsigned int ownerIndex;
 *     L3Address sourceAddr;
 *     L3Address ownerAddr;
 *     L3Address destAddr;
 *     simtime_t destContactDuration;
 * }
 * </pre>
 */
class EnquireMessage : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;
    unsigned int hostIndex;
    unsigned int destIndex;
    unsigned int seqNum;
    unsigned int ownerIndex;
    L3Address sourceAddr;
    L3Address ownerAddr;
    L3Address destAddr;
    ::omnetpp::simtime_t destContactDuration;

  private:
    void copy(const EnquireMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EnquireMessage&);

  public:
    EnquireMessage(const char *name=nullptr);
    EnquireMessage(const EnquireMessage& other);
    virtual ~EnquireMessage();
    EnquireMessage& operator=(const EnquireMessage& other);
    virtual EnquireMessage *dup() const {return new EnquireMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
    virtual unsigned int getHostIndex() const;
    virtual void setHostIndex(unsigned int hostIndex);
    virtual unsigned int getDestIndex() const;
    virtual void setDestIndex(unsigned int destIndex);
    virtual unsigned int getSeqNum() const;
    virtual void setSeqNum(unsigned int seqNum);
    virtual unsigned int getOwnerIndex() const;
    virtual void setOwnerIndex(unsigned int ownerIndex);
    virtual L3Address& getSourceAddr();
    virtual const L3Address& getSourceAddr() const {return const_cast<EnquireMessage*>(this)->getSourceAddr();}
    virtual void setSourceAddr(const L3Address& sourceAddr);
    virtual L3Address& getOwnerAddr();
    virtual const L3Address& getOwnerAddr() const {return const_cast<EnquireMessage*>(this)->getOwnerAddr();}
    virtual void setOwnerAddr(const L3Address& ownerAddr);
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<EnquireMessage*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual ::omnetpp::simtime_t getDestContactDuration() const;
    virtual void setDestContactDuration(::omnetpp::simtime_t destContactDuration);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EnquireMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EnquireMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:134</tt> by nedtool.
 * <pre>
 * class EnquireResponse extends EPFControlPacket
 * {
 *     unsigned int packetType = Response;
 *     unsigned int hostIndex;
 *     unsigned int destIndex;
 *     unsigned int ownerIndex;
 *     unsigned int seqNum;
 *     L3Address sourceAddr;
 *     L3Address ownerAddr;
 *     L3Address respondTo;
 *     L3Address destAddr;
 *     bool okToSend;
 *     bool destReached;
 * }
 * </pre>
 */
class EnquireResponse : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;
    unsigned int hostIndex;
    unsigned int destIndex;
    unsigned int ownerIndex;
    unsigned int seqNum;
    L3Address sourceAddr;
    L3Address ownerAddr;
    L3Address respondTo;
    L3Address destAddr;
    bool okToSend;
    bool destReached;

  private:
    void copy(const EnquireResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EnquireResponse&);

  public:
    EnquireResponse(const char *name=nullptr);
    EnquireResponse(const EnquireResponse& other);
    virtual ~EnquireResponse();
    EnquireResponse& operator=(const EnquireResponse& other);
    virtual EnquireResponse *dup() const {return new EnquireResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
    virtual unsigned int getHostIndex() const;
    virtual void setHostIndex(unsigned int hostIndex);
    virtual unsigned int getDestIndex() const;
    virtual void setDestIndex(unsigned int destIndex);
    virtual unsigned int getOwnerIndex() const;
    virtual void setOwnerIndex(unsigned int ownerIndex);
    virtual unsigned int getSeqNum() const;
    virtual void setSeqNum(unsigned int seqNum);
    virtual L3Address& getSourceAddr();
    virtual const L3Address& getSourceAddr() const {return const_cast<EnquireResponse*>(this)->getSourceAddr();}
    virtual void setSourceAddr(const L3Address& sourceAddr);
    virtual L3Address& getOwnerAddr();
    virtual const L3Address& getOwnerAddr() const {return const_cast<EnquireResponse*>(this)->getOwnerAddr();}
    virtual void setOwnerAddr(const L3Address& ownerAddr);
    virtual L3Address& getRespondTo();
    virtual const L3Address& getRespondTo() const {return const_cast<EnquireResponse*>(this)->getRespondTo();}
    virtual void setRespondTo(const L3Address& respondTo);
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<EnquireResponse*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual bool getOkToSend() const;
    virtual void setOkToSend(bool okToSend);
    virtual bool getDestReached() const;
    virtual void setDestReached(bool destReached);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EnquireResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EnquireResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/epf/EPFControlPackets.msg:148</tt> by nedtool.
 * <pre>
 * class DataMessage extends EPFControlPacket
 * {
 *     unsigned int packetType = Data;
 *     unsigned int hostIndex;
 *     unsigned int destIndex;
 *     unsigned int ownerIndex;
 *     unsigned int seqNum;
 *     L3Address sourceAddr;
 *     L3Address destAddr;
 *     L3Address respondTo;
 *     L3Address ownerAddr;
 *     char data[20];
 * }
 * </pre>
 */
class DataMessage : public ::inet::EPFControlPacket
{
  protected:
    unsigned int packetType;
    unsigned int hostIndex;
    unsigned int destIndex;
    unsigned int ownerIndex;
    unsigned int seqNum;
    L3Address sourceAddr;
    L3Address destAddr;
    L3Address respondTo;
    L3Address ownerAddr;
    char data[20];

  private:
    void copy(const DataMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DataMessage&);

  public:
    DataMessage(const char *name=nullptr);
    DataMessage(const DataMessage& other);
    virtual ~DataMessage();
    DataMessage& operator=(const DataMessage& other);
    virtual DataMessage *dup() const {return new DataMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getPacketType() const;
    virtual void setPacketType(unsigned int packetType);
    virtual unsigned int getHostIndex() const;
    virtual void setHostIndex(unsigned int hostIndex);
    virtual unsigned int getDestIndex() const;
    virtual void setDestIndex(unsigned int destIndex);
    virtual unsigned int getOwnerIndex() const;
    virtual void setOwnerIndex(unsigned int ownerIndex);
    virtual unsigned int getSeqNum() const;
    virtual void setSeqNum(unsigned int seqNum);
    virtual L3Address& getSourceAddr();
    virtual const L3Address& getSourceAddr() const {return const_cast<DataMessage*>(this)->getSourceAddr();}
    virtual void setSourceAddr(const L3Address& sourceAddr);
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<DataMessage*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual L3Address& getRespondTo();
    virtual const L3Address& getRespondTo() const {return const_cast<DataMessage*>(this)->getRespondTo();}
    virtual void setRespondTo(const L3Address& respondTo);
    virtual L3Address& getOwnerAddr();
    virtual const L3Address& getOwnerAddr() const {return const_cast<DataMessage*>(this)->getOwnerAddr();}
    virtual void setOwnerAddr(const L3Address& ownerAddr);
    virtual unsigned int getDataArraySize() const;
    virtual char getData(unsigned int k) const;
    virtual void setData(unsigned int k, char data);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DataMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DataMessage& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_EPFCONTROLPACKETS_M_H

